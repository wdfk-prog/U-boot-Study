[TOC]

# 声明
## .globl 声明全局符号
- 使其在链接过程中可以被其他文件引用

## .type  声明符号类型
- `.type reset, %function`指令指定reset是一个函数类型的符号

## .irp 用于重复生成代码
- GNU汇编器（GAS）中的一个宏指令
- 它允许你定义一个循环宏，循环变量会依次取指定的值，并在每次循环中生成相应的代码。
- 语法如下：
    ```assembly
    .irp variable, value1, value2, ..., valueN
        code
    .endr
    ```
    - variable 是循环变量的名称。
    - value1, value2, ..., valueN 是循环变量依次取的值。
    - code 是在每次循环中生成的代码，可以使用循环变量。
- 例如：
    ```assembly
    .irp reg, r0, r1, r2, r3
        mov \reg, #0
    .endr
    ```
    - 这段代码会生成如下指令：
    ```assembly
        mov r0, #0
        mov r1, #0
        mov r2, #0
        mov r3, #0
    ```

## .macro 定义宏
`.macro` 指令用于在汇编代码中定义一个宏。宏是一段可以重复使用的代码块，可以带有参数。定义宏后，可以在代码中多次调用它，每次调用时可以传递不同的参数。

- 语法如下：
    ```assembly
    .macro macro_name, param1, param2, ...
        code
    .endm
    ```
    - `macro_name` 是宏的名称。
    - `param1, param2, ...` 是宏的参数。
    - `code` 是宏的主体代码，可以使用参数。
- 在汇编宏中，除了使用 \c 这种特殊情况外，还可以使用其他类似的转义字符来处理宏参数。以下是一些常见的情况：
    - 普通参数：直接使用宏参数名，例如 \param。
    - 带有条件码的参数：使用 \c 这种形式来表示条件码。
    - 带有寄存器的参数：使用 \reg 这种形式来表示寄存器。

## .section 用于定义代码段
- 通过使用 .section 指令，开发者可以明确地指定代码和数据在内存中的布局，从而更好地控制程序的结构和行为。

## .long 用于定义一个32位的整数

## .irp .endr 用于重复生成代码

- .rept 和 .endr 是汇编语言中的伪指令，用于重复生成代码或数据。
- .rept 指令用于指定重复的次数。
- .endr 指令用于结束重复块。
- 在 .rept 和 .endr 之间的代码或数据将被重复指定的次数。

# 寄存器

## pc 程序计数器
- pc寄存器存储的是当前指令的地址

## lr 链接寄存器
- lr寄存器存储的是函数调用的返回地址

## sp 堆栈指针寄存器
- 它用于指向当前堆栈的顶部，管理函数调用和局部变量的存储。堆栈通常用于保存函数的返回地址、局部变量和临时数据

## r0 - r12 通用寄存器(General Purpose Registers）
- r0 到 r3：这些寄存器通常用于函数调用时传递参数和返回值。在 ARM 的调用约定中，前四个参数通过 r0 到 r3 传递，函数的返回值也通过 r0 返回。
- r4 到 r11：这些寄存器通常用于保存局部变量和中间计算结果。它们在函数调用过程中需要保存和恢复，以确保调用者和被调用者之间的数据一致性。
- r12（也称为 IP，Intra-Procedure-call scratch register）：这个寄存器通常用作临时寄存器，在函数调用过程中可以被自由使用，不需要保存和恢复。

# 指令
## b 无条件分支
- b.w 用于指示宽分支指令
- b.条件码，用于指示条件分支指令

## mov 数据传送
### mov pc, lr  用于从子程序返回
### mov r0, #0  用于将0传送到r0寄存器

## ldr 从内存中加载数据
- 不带括号与带()括号的 ldr 指令用于加载立即数或符号地址到寄存器中。
```asm
ldr r1, =0x1000  // 将立即数 0x1000 加载到寄存器 r1 中
ldr r0, =CONFIG_TEXT_BASE  // 将 CONFIG_TEXT_BASE 的值加载到寄存器 r0 中
```

- 带[]括号的 ldr 指令用于从内存地址加载数据到寄存器中
```asm
ldr r1, =0x1000  // 将立即数 0x1000 加载到寄存器 r1 中
ldr r0, [r1]  // 将内存地址 0x1000 中的值加载到寄存器 r0 中
```
## bic 按位清零（Bit Clear）
- bic 指令的工作原理是将源寄存器的值与立即数或另一个寄存器的按位取反值进行按位与运算。结果存储在目标寄存器中。
- 语法如下：
    ```assembly
    bic dest_reg, src_reg, imm
    ```
    - `dest_reg` 是目标寄存器，存储运算结果。
    - `src_reg` 是源寄存器，存储要清零的值。
    - `imm` 是立即数或另一个寄存器的值，用于按位取反。

## push 压入堆栈
- ` push {r4, lr}` 将r4和lr寄存器的值压入堆栈;这通常用于在函数调用时保存寄存器的值，以便在函数返回时恢复。