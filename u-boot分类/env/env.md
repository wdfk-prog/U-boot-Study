# env
## U_BOOT_ENV_LOCATION
- 通过该宏定义环境变量的位置
```c
/*
 * Define a callback that can be associated with variables.
 * when associated through the ".callbacks" environment variable, the callback
 * will be executed any time the variable is inserted, overwritten, or deleted.
 *
 * For SPL these are silently dropped to reduce code size, since environment
 * callbacks are not supported with SPL.
 */
#ifdef CONFIG_XPL_BUILD
#define U_BOOT_ENV_CALLBACK(name, callback) \
    static inline __maybe_unused void _u_boot_env_noop_##name(void) \
    { \
        (void)callback; \
    }
#else
#define U_BOOT_ENV_CALLBACK(name, callback) \
    ll_entry_declare(struct env_clbk_tbl, name, env_clbk) = \
    {#name, callback}
#endif

```

## default_environment
```c
const char default_environment[] = {
#endif
#ifndef CONFIG_USE_DEFAULT_ENV_FILE
#ifdef  CONFIG_ENV_CALLBACK_LIST_DEFAULT
    ENV_CALLBACK_VAR "=" CONFIG_ENV_CALLBACK_LIST_DEFAULT "\0"
#endif
#ifdef  CONFIG_ENV_FLAGS_LIST_DEFAULT
    ENV_FLAGS_VAR "=" CONFIG_ENV_FLAGS_LIST_DEFAULT "\0"
#endif
#ifdef  CONFIG_USE_BOOTARGS
    "bootargs=" CONFIG_BOOTARGS         "\0"
#endif
#ifdef  CONFIG_BOOTCOMMAND
    "bootcmd="  CONFIG_BOOTCOMMAND      "\0"
#endif
#if defined(CONFIG_BOOTDELAY)
    "bootdelay="    __stringify(CONFIG_BOOTDELAY)   "\0"
#endif
#if !defined(CONFIG_OF_SERIAL_BAUD) && defined(CONFIG_BAUDRATE) && (CONFIG_BAUDRATE >= 0)
    "baudrate=" __stringify(CONFIG_BAUDRATE)    "\0"
#endif
#ifdef  CONFIG_LOADS_ECHO
    "loads_echo="   __stringify(CONFIG_LOADS_ECHO)  "\0"
#endif
#ifdef  CONFIG_ETHPRIME
    "ethprime=" CONFIG_ETHPRIME         "\0"
#endif
#ifdef  CONFIG_USE_IPADDR
    "ipaddr="   CONFIG_IPADDR           "\0"
#endif
#ifdef  CONFIG_USE_SERVERIP
    "serverip=" CONFIG_SERVERIP         "\0"
#endif
#ifdef  CONFIG_SYS_DISABLE_AUTOLOAD
    "autoload=0\0"
#endif
#ifdef  CONFIG_PREBOOT_DEFINED
    "preboot="  CONFIG_PREBOOT          "\0"
#endif
#ifdef  CONFIG_USE_ROOTPATH
    "rootpath=" CONFIG_ROOTPATH         "\0"
#endif
#ifdef  CONFIG_USE_GATEWAYIP
    "gatewayip="    CONFIG_GATEWAYIP        "\0"
#endif
#ifdef  CONFIG_USE_NETMASK
    "netmask="  CONFIG_NETMASK          "\0"
#endif
#ifdef  CONFIG_USE_HOSTNAME
    "hostname=" CONFIG_HOSTNAME         "\0"
#endif
#ifdef CONFIG_USE_BOOTFILE
    "bootfile=" CONFIG_BOOTFILE         "\0"
#endif
#ifdef  CONFIG_SYS_LOAD_ADDR
    "loadaddr=" __stringify(CONFIG_SYS_LOAD_ADDR)"\0"
#endif
#ifdef  CONFIG_ENV_VARS_UBOOT_CONFIG
    "arch="     CONFIG_SYS_ARCH         "\0"
#ifdef CONFIG_SYS_CPU
    "cpu="      CONFIG_SYS_CPU          "\0"
#endif
#ifdef CONFIG_SYS_BOARD
    "board="    CONFIG_SYS_BOARD        "\0"
    "board_name="   CONFIG_SYS_BOARD        "\0"
#endif
#ifdef CONFIG_SYS_VENDOR
    "vendor="   CONFIG_SYS_VENDOR       "\0"
#endif
#ifdef CONFIG_SYS_SOC
    "soc="      CONFIG_SYS_SOC          "\0"
#endif
#ifdef CONFIG_USB_HOST
    "usb_ignorelist="
#ifdef CONFIG_USB_KEYBOARD
    /* Ignore Yubico devices. Currently only a single USB keyboard device is
     * supported and the emulated HID keyboard Yubikeys present is useless
     * as keyboard.
     */
    "0x1050:*,"
#endif
    "\0"
#endif
#ifdef CONFIG_ENV_IMPORT_FDT
    "env_fdt_path=" CONFIG_ENV_FDT_PATH     "\0"
#endif
#endif
#if defined(CONFIG_BOOTCOUNT_BOOTLIMIT) && (CONFIG_BOOTCOUNT_BOOTLIMIT > 0)
    "bootlimit="    __stringify(CONFIG_BOOTCOUNT_BOOTLIMIT)"\0"
#endif
#ifdef CONFIG_MTDIDS_DEFAULT
     "mtdids="  CONFIG_MTDIDS_DEFAULT       "\0"
#endif
#ifdef CONFIG_MTDPARTS_DEFAULT
    "mtdparts=" CONFIG_MTDPARTS_DEFAULT     "\0"
#endif
#ifdef CONFIG_EXTRA_ENV_TEXT
    /* This is created in the Makefile */
    CONFIG_EXTRA_ENV_TEXT
#endif
#ifdef  CFG_EXTRA_ENV_SETTINGS
    CFG_EXTRA_ENV_SETTINGS
#endif
#ifdef CONFIG_OF_SERIAL_BAUD
    /* Padding for baudrate at the end when environment is writable */
    "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
#endif
    "\0"
#else /* CONFIG_USE_DEFAULT_ENV_FILE */
#include "generated/defaultenv_autogenerated.h"
#endif
#ifdef DEFAULT_ENV_INSTANCE_EMBEDDED
    }
#endif
};

const char default_environment[] = {
    "bootargs=console=ttySTM0,2000000 root=/dev/ram "
    "loglevel=8\000bootcmd=bootm "
    "90080000\000bootdelay=3\000baudrate=2000000\000loadaddr="
    "0xc1800000\000arch=arm\000cpu=armv7m\000board=stm32h750-art-pi\000board_"
    "name=stm32h750-art-pi\000vendor=st\000soc=stm32h7\000kernel_addr_r="
    "0xC0008000\000fdtfile=stm32h750i-art-pi.dtb\000fdt_addr_r="
    "0xC0408000\000scriptaddr=0xC0418000\000pxefile_addr_r="
    "0xC0428000\000ramdisk_addr_r=0xC0438000\000mmc_boot=if mmc dev ${devnum}; "
    "then devtype=mmc; run scan_dev_for_boot_part; fi\000boot_prefixes=/ "
    "/boot/\000boot_scripts=boot.scr.uimg "
    "boot.scr\000boot_script_dhcp=boot.scr.uimg\000boot_targets=mmc0 "
    "\000boot_syslinux_conf=extlinux/extlinux.conf\000boot_extlinux=sysboot "
    "${devtype} ${devnum}:${distro_bootpart} any ${scriptaddr} "
    "${prefix}${boot_syslinux_conf}\000scan_dev_for_extlinux=if test -e "
    "${devtype} ${devnum}:${distro_bootpart} ${prefix}${boot_syslinux_conf}; "
    "then echo Found ${prefix}${boot_syslinux_conf}; run boot_extlinux; echo "
    "EXTLINUX FAILED: continuing...; fi\000boot_a_script=load ${devtype} "
    "${devnum}:${distro_bootpart} ${scriptaddr} ${prefix}${script}; source "
    "${scriptaddr}\000scan_dev_for_scripts=for script in ${boot_scripts}; do "
    "if test -e ${devtype} ${devnum}:${distro_bootpart} ${prefix}${script}; "
    "then echo Found U-Boot script ${prefix}${script}; run boot_a_script; echo "
    "SCRIPT FAILED: continuing...; fi; done\000scan_dev_for_boot=echo Scanning "
    "${devtype} ${devnum}:${distro_bootpart}...; for prefix in "
    "${boot_prefixes}; do run scan_dev_for_extlinux; run scan_dev_for_scripts; "
    "done;\000scan_dev_for_boot_part=part list ${devtype} ${devnum} -bootable "
    "devplist; env exists devplist || setenv devplist 1; for distro_bootpart "
    "in ${devplist}; do if fstype ${devtype} ${devnum}:${distro_bootpart} "
    "bootfstype; then part uuid ${devtype} ${devnum}:${distro_bootpart} "
    "distro_bootpart_uuid ; run scan_dev_for_boot; fi; done; setenv "
    "devplist\000bootcmd_mmc0=devnum=0; run mmc_boot\000distro_bootcmd=for "
    "target in ${boot_targets}; do run bootcmd_${target}; done\000\000"}
```

## env_locations
```c
static enum env_location env_locations[] = {
#ifdef CONFIG_ENV_IS_IN_EEPROM
    ENVL_EEPROM,
#endif
#ifdef CONFIG_ENV_IS_IN_EXT4
    ENVL_EXT4,
#endif
#ifdef CONFIG_ENV_IS_IN_FAT
    ENVL_FAT,
#endif
#ifdef CONFIG_ENV_IS_IN_FLASH
    ENVL_FLASH,
#endif
#ifdef CONFIG_ENV_IS_IN_MMC
    ENVL_MMC,
#endif
#ifdef CONFIG_ENV_IS_IN_NAND
    ENVL_NAND,
#endif
#ifdef CONFIG_ENV_IS_IN_NVRAM
    ENVL_NVRAM,
#endif
#ifdef CONFIG_ENV_IS_IN_REMOTE
    ENVL_REMOTE,
#endif
#ifdef CONFIG_ENV_IS_IN_SPI_FLASH
    ENVL_SPI_FLASH,
#endif
#ifdef CONFIG_ENV_IS_IN_UBI
    ENVL_UBI,
#endif
#ifdef CONFIG_ENV_IS_NOWHERE
    ENVL_NOWHERE,
#endif
};
```

## env/env.c
- 从其他存储位置加载环境变量
- 其他地方没有存储则执行默认的环境变量
- 这样可以在使用在其他地方配置好环境变量,然后在u-boot中直接使用

### env_init
```c
int env_init(void)
{
    struct env_driver *drv;
    int ret = -ENOENT;
    int prio;
    // 从优先级0开始查找环境驱动,直到没有环境驱动
    for (prio = 0; (drv = env_driver_lookup(ENVOP_INIT, prio)); prio++) {
        // 如果环境驱动的init函数存在,则调用init函数
        if (!drv->init || !(ret = drv->init())) // 如果初始化成功
            env_set_inited(drv->location);
        if (ret == -ENOENT) // 如果不需要初始化
            env_set_inited(drv->location);  //gd->env_has_init |= BIT(location);

        debug("%s: Environment %s init done (ret=%d)\n", __func__,
              drv->name, ret);

        if (gd->env_valid == ENV_INVALID)
            ret = -ENOENT;
    }
    // 如果没有找到环境驱动,则返回-ENOENT
    if (!prio)
        return -ENODEV;
    // 找到了环境驱动,但是环境无效,则使用默认环境
    if (ret == -ENOENT) {
        gd->env_addr = (ulong)&default_environment[0];
        gd->env_valid = ENV_VALID;

        return 0;
    }

    return ret;
}
```

### env_driver_lookup
- 根据优先级和操作查找环境驱动并返回
```c
static struct env_driver *env_driver_lookup(enum env_operation op, int prio)
{
    enum env_location loc = env_get_location(op, prio);
    struct env_driver *drv;

    if (loc == ENVL_UNKNOWN)
        return NULL;

    drv = _env_driver_lookup(loc);
    if (!drv) {
        debug("%s: No environment driver for location %d\n", __func__,
              loc);
        return NULL;
    }

    return drv;
}
```

### arch_env_get_location
- 根据优先级返回环境位置
```c
__weak enum env_location arch_env_get_location(enum env_operation op, int prio)
{
    if (prio >= ARRAY_SIZE(env_locations))
        return ENVL_UNKNOWN;

    return env_locations[prio];
}
```

### _env_driver_lookup
- 在段中查找环境驱动,匹配符合的环境位置
```c
static struct env_driver *_env_driver_lookup(enum env_location loc)
{
    struct env_driver *drv;
    const int n_ents = ll_entry_count(struct env_driver, env_driver);
    struct env_driver *entry;

    drv = ll_entry_start(struct env_driver, env_driver);
    for (entry = drv; entry != drv + n_ents; entry++) {
        if (loc == entry->location)
            return entry;
    }

    /* Not found */
    return NULL;
}
```

## env/common.c
### env_get_from_linear
```c
static int env_get_from_linear(const char *env, const char *name, char *buf,
                   unsigned len)
{
    const char *p, *end;
    size_t name_len;

    if (name == NULL || *name == '\0')
        return -1;

    name_len = strlen(name);

    for (p = env; *p != '\0'; p = end + 1) {
        const char *value;
        unsigned res;
        //识别到数组结束符
        for (end = p; *end != '\0'; ++end)
            if (end - env >= CONFIG_ENV_SIZE)
                return -1;

        if (strncmp(name, p, name_len) || p[name_len] != '=')
            continue;
        //找到name
        value = &p[name_len + 1];

        res = end - value;
        //拷贝环境变量的值
        memcpy(buf, value, min(len, res + 1));

        if (len <= res) {
            buf[len - 1] = '\0';
            printf("env_buf [%u bytes] too small for value of \"%s\"\n",
                   len, name);
        }

        return res;
    }

    return -1;
}
```

## env/nowhere.c 
- 环墫位置为NOWHERE,无处可去的默认位置会执行这里
- 根据env_locations的定义,这里是最低优先级的执行位置

```c
U_BOOT_ENV_LOCATION(nowhere) = {
    .location   = ENVL_NOWHERE,
    .init       = env_nowhere_init, //gd->env_valid = ENV_INVALID;
    .load       = env_nowhere_load,
    ENV_NAME("nowhere")
};
```